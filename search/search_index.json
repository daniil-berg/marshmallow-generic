{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"marshmallow-generic","text":"<p>Generic schema with full typing support and minimal boilerplate</p> <p>Documentation:  daniil-berg.github.io/marshmallow-generic </p> <p>Source Code:  github.com/daniil-berg/marshmallow-generic </p> <p>Extension for <code>marshmallow</code> to make deserialization to objects easier and improve type safety.</p> <p>The main <code>GenericSchema</code> class extends <code>marshmallow.Schema</code> making it generic in terms of the class that data should be deserialized to, when calling <code>load</code>/<code>loads</code>.</p> <p>With <code>GenericSchema</code> there is no need to explicitly write <code>post_load</code> hooks to initialize the object anymore. \ud83c\udf89</p> <p>If the \"model\" class is (for example) <code>User</code>, it just needs to be passed as the type argument, when subclassing <code>GenericSchema</code>. Depending on whether <code>many</code> is <code>True</code> or not, the output of the <code>load</code>/<code>loads</code> method will then be automatically inferred as either <code>User</code> or <code>list[User]</code> by any competent type checker. \u2728</p>"},{"location":"#usage-example","title":"Usage Example","text":"<pre><code>from marshmallow import fields\nfrom marshmallow_generic import GenericSchema\n\n\nclass User:\n    def __init__(self, name: str, email: str) -&gt; None:\n        self.name = name\n        self.email = email\n\n    def __repr__(self) -&gt; str:\n        return \"&lt;User(name={self.name!r})&gt;\".format(self=self)\n\n...\n\nclass UserSchema(GenericSchema[User]):\n    name = fields.Str()\n    email = fields.Email()\n\n\nuser_data = {\"name\": \"Monty\", \"email\": \"monty@python.org\"}\nschema = UserSchema()\nsingle_user = schema.load(user_data)\nprint(single_user)  # &lt;User(name='Monty')&gt;\n\njson_data = '''[\n    {\"name\": \"Monty\", \"email\": \"monty@python.org\"},\n    {\"name\": \"Ronnie\", \"email\": \"ronnie@stones.com\"}\n]'''\nmultiple_users = schema.loads(json_data, many=True)\nprint(multiple_users)  # [&lt;User(name='Monty')&gt;, &lt;User(name='Ronnie')&gt;]\n</code></pre> <p>Adding <code>reveal_type(single_user)</code> and <code>reveal_type(multiple_users)</code> at the bottom and running that code through <code>mypy</code> would yield the following output:</p> <pre><code># note: Revealed type is \"User\"\n# note: Revealed type is \"builtins.list[User]\"\n</code></pre> <p>With the regular <code>marshmallow.Schema</code>, the output of <code>mypy</code> would instead be this:</p> <pre><code># note: Revealed type is \"Any\"\n# note: Revealed type is \"Any\"\n</code></pre> <p>This also means your IDE will be able to infer the types and thus provide useful auto-suggestions for the loaded objects. \ud83d\udc68\u200d\ud83d\udcbb</p> <p>Here is PyCharm with the example from above:</p> <p></p>"},{"location":"#installation","title":"Installation","text":"<p><code>pip install marshmallow-generic</code></p>"},{"location":"#dependencies","title":"Dependencies","text":"<p>Python Version <code>3.9+</code> and <code>marshmallow</code> (duh)</p>"},{"location":"api_reference/decorators/","title":"Decorators","text":"<p>Typed overloads for the <code>marshmallow.decorators</code> module.</p> <p>Implements decorators as generic in terms of the decorated method types.</p>"},{"location":"api_reference/decorators/#marshmallow_generic.decorators.post_load","title":"post_load","text":"<pre><code>post_load(\n    fn: Optional[Callable[..., Any]] = None,\n    pass_many: bool = False,\n    pass_original: bool = False,\n) -&gt; Callable[..., Any]\n</code></pre> <p>Register a method to invoke after deserializing an object.</p> <p>Typed overload of the original <code>marshmallow.post_load</code> decorator function. Generic to ensure that the decorated function retains its type. Runtime behavior is unchanged.</p> <p>Receives the deserialized data and returns the processed data. By default it receives a single object at a time, transparently handling the <code>many</code> argument passed to the <code>Schema.load</code> call.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Optional[Callable[P, R]]</code> <p>The function to decorate or <code>None</code>; if a function is supplied, a decorated version of it is returned; if <code>None</code> the decorator is returned with its other arguments already bound.</p> <code>None</code> <code>pass_many</code> <code>bool</code> <p>If <code>True</code>, the raw data (which may be a collection) is passed</p> <code>False</code> <code>pass_original</code> <code>bool</code> <p>If <code>True</code>, the original data (before deserializing) will be passed as an additional argument to the method</p> <code>False</code> <p>Returns:</p> Type Description <code>Callable[P, R]</code> <p>if <code>fn</code> is passed a function</p> <code>Callable[[Callable[P, R]], Callable[P, R]]</code> <p>if <code>fn</code> is <code>None</code></p>"},{"location":"api_reference/schema/","title":"Schema","text":"<p>Definition of the <code>GenericSchema</code> base class.</p> <p>For details about the inherited methods and attributes, see the official documentation of <code>marshmallow.Schema</code>.</p>"},{"location":"api_reference/schema/#marshmallow_generic.schema.GenericSchema","title":"GenericSchema","text":"<p>         Bases: <code>GenericInsightMixin1[Model]</code>, <code>Schema</code></p> <p>Generic schema parameterized by a <code>Model</code> class.</p> <p>Data will always be deserialized to instances of that <code>Model</code> class.</p> <p>Note</p> <p>The <code>Model</code> referred to throughout the documentation is a type variable, not any concrete class. For more information about type variables, see the \"Generics\" section in PEP 484.</p> <p>Registers a <code>post_load</code> hook to pass validated data to the constructor of the specified <code>Model</code>.</p> <p>Requires a specific (non-generic) class to be passed as the <code>Model</code> type argument for deserialization to work properly:</p> <pre><code>class Foo:  # Model\n    ...\n\nclass FooSchema(GenericSchema[Foo]):\n    ...\n</code></pre>"},{"location":"api_reference/schema/#marshmallow_generic.schema.GenericSchema.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    only: Union[Sequence[str], set[str], None] = None,\n    exclude: Union[Sequence[str], set[str]] = (),\n    context: Union[dict[str, Any], None] = None,\n    load_only: Union[Sequence[str], set[str]] = (),\n    dump_only: Union[Sequence[str], set[str]] = (),\n    partial: Union[bool, Sequence[str], set[str]] = False,\n    unknown: Optional[str] = None,\n    many: Optional[bool] = None\n) -&gt; None\n</code></pre> <p>Emits a warning, if the <code>many</code> argument is not <code>None</code>.</p> <p>Otherwise the same as in <code>marshmallow.Schema</code>.</p> <p>Parameters:</p> Name Type Description Default <code>only</code> <code>Union[Sequence[str], set[str], None]</code> <p>Whitelist of the declared fields to select when instantiating the Schema. If <code>None</code>, all fields are used. Nested fields can be represented with dot delimiters.</p> <code>None</code> <code>exclude</code> <code>Union[Sequence[str], set[str]]</code> <p>Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both <code>only</code> and <code>exclude</code>, it is not used. Nested fields can be represented with dot delimiters.</p> <code>()</code> <code>context</code> <code>Union[dict[str, Any], None]</code> <p>Optional context passed to <code>Method</code> and <code>Function</code> fields.</p> <code>None</code> <code>load_only</code> <code>Union[Sequence[str], set[str]]</code> <p>Fields to skip during serialization (write-only fields)</p> <code>()</code> <code>dump_only</code> <code>Union[Sequence[str], set[str]]</code> <p>Fields to skip during deserialization (read-only fields)</p> <code>()</code> <code>partial</code> <code>Union[bool, Sequence[str], set[str]]</code> <p>Whether to ignore missing fields and not require any fields declared. Propagates down to <code>Nested</code> fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields.</p> <code>False</code> <code>unknown</code> <code>Optional[str]</code> <p>Whether to exclude, include, or raise an error for unknown fields in the data. Use <code>EXCLUDE</code>, <code>INCLUDE</code> or <code>RAISE</code>.</p> <code>None</code> <code>many</code> <code>Optional[bool]</code> <p>Warning</p> <p>Specifying this option schema-wide undermines the type safety that this class aims to provide and passing any value other than <code>None</code> will trigger a warning. Use the method-specific <code>many</code> parameter, when calling <code>dump</code>/ <code>dumps</code> or <code>load</code>/ <code>loads</code> instead.</p> <code>None</code>"},{"location":"api_reference/schema/#marshmallow_generic.schema.GenericSchema.dump","title":"dump","text":"<pre><code>dump(\n    obj: Union[Model, Iterable[Model]], *, many: Optional[bool] = None\n) -&gt; Union[dict[str, Any], list[dict[str, Any]]]\n</code></pre> <p>Serializes <code>Model</code> objects to native Python data types.</p> <p>Same as <code>marshmallow.Schema.dump</code> at runtime.</p> <p>Annotations ensure that type checkers will infer the return type correctly based on the <code>many</code> argument, and also enforce the <code>obj</code> argument to be an a <code>list</code> of <code>Model</code> instances, if <code>many</code> is set to <code>True</code> or a single instance of it, if <code>many</code> is <code>False</code> (or omitted).</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Union[Model, Iterable[Model]]</code> <p>The object or iterable of objects to serialize</p> required <code>many</code> <code>Optional[bool]</code> <p>Whether to serialize <code>obj</code> as a collection. If <code>None</code>, the value for <code>self.many</code> is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>if <code>many</code> is set to <code>False</code></p> <code>list[dict[str, Any]]</code> <p>if <code>many</code> is set to <code>True</code></p>"},{"location":"api_reference/schema/#marshmallow_generic.schema.GenericSchema.dumps","title":"dumps","text":"<pre><code>dumps(\n    obj: Union[Model, Iterable[Model]],\n    *args: Any,\n    many: Optional[bool] = None,\n    **kwargs: Any\n) -&gt; str\n</code></pre> <p>Same as <code>dump</code>, but returns a JSON-encoded string.</p>"},{"location":"api_reference/schema/#marshmallow_generic.schema.GenericSchema.instantiate","title":"instantiate","text":"<pre><code>instantiate(data: dict[str, Any], **_kwargs: Any) -&gt; Model\n</code></pre> <p>Unpacks <code>data</code> into the constructor of the specified <code>Model</code>.</p> <p>Registered as a <code>@post_load</code> hook for the schema.</p> <p>Warning</p> <p>You should probably not use this method directly. No parsing, transformation or validation of any kind is done in this method. The <code>data</code> is passed to the <code>Model</code> constructor \"as is\".</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>The validated data after deserialization; will be unpacked into the constructor of the specified <code>Model</code> class.</p> required <p>Returns:</p> Type Description <code>Model</code> <p>Instance of the schema's <code>Model</code> initialized with <code>**data</code></p>"},{"location":"api_reference/schema/#marshmallow_generic.schema.GenericSchema.load","title":"load","text":"<pre><code>load(\n    data: Union[Mapping[str, Any], Iterable[Mapping[str, Any]]],\n    *,\n    many: Optional[bool] = None,\n    partial: Union[bool, Sequence[str], set[str], None] = None,\n    unknown: Optional[str] = None\n) -&gt; Union[list[Model], Model]\n</code></pre> <p>Deserializes data to objects of the specified <code>Model</code> class.</p> <p>Same as <code>marshmallow.Schema.load</code> at runtime, but data will always pass through the <code>instantiate</code> hook after deserialization.</p> <p>Annotations ensure that type checkers will infer the return type correctly based on the <code>Model</code> type argument of the class.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[Mapping[str, Any], Iterable[Mapping[str, Any]]]</code> <p>The data to deserialize</p> required <code>many</code> <code>Optional[bool]</code> <p>Whether to deserialize <code>data</code> as a collection. If <code>None</code>, the value for <code>self.many</code> is used.</p> <code>None</code> <code>partial</code> <code>Union[bool, Sequence[str], set[str], None]</code> <p>Whether to ignore missing fields and not require any fields declared. Propagates down to <code>Nested</code> fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields.</p> <code>None</code> <code>unknown</code> <code>Optional[str]</code> <p>Whether to exclude, include, or raise an error for unknown fields in the data. Use <code>EXCLUDE</code>, <code>INCLUDE</code> or <code>RAISE</code>. If <code>None</code>, the value for <code>self.unknown</code> is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>Model</code> <p>if <code>many</code> is set to <code>False</code></p> <code>list[Model]</code> <p>if <code>many</code> is set to <code>True</code></p>"},{"location":"api_reference/schema/#marshmallow_generic.schema.GenericSchema.loads","title":"loads","text":"<pre><code>loads(\n    json_data: str,\n    *,\n    many: Optional[bool] = None,\n    partial: Union[bool, Sequence[str], set[str], None] = None,\n    unknown: Optional[str] = None,\n    **kwargs: Any\n) -&gt; Union[list[Model], Model]\n</code></pre> <p>Deserializes data to objects of the specified <code>Model</code> class.</p> <p>Same as <code>marshmallow.Schema.loads</code> at runtime, but data will always pass through the <code>instantiate</code> hook after deserialization.</p> <p>Annotations ensure that type checkers will infer the return type correctly based on the <code>Model</code> type argument of the class.</p> <p>Parameters:</p> Name Type Description Default <code>json_data</code> <code>str</code> <p>A JSON string of the data to deserialize</p> required <code>many</code> <code>Optional[bool]</code> <p>Whether to deserialize <code>data</code> as a collection. If <code>None</code>, the value for <code>self.many</code> is used.</p> <code>None</code> <code>partial</code> <code>Union[bool, Sequence[str], set[str], None]</code> <p>Whether to ignore missing fields and not require any fields declared. Propagates down to <code>Nested</code> fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields.</p> <code>None</code> <code>unknown</code> <code>Optional[str]</code> <p>Whether to exclude, include, or raise an error for unknown fields in the data. Use <code>EXCLUDE</code>, <code>INCLUDE</code> or <code>RAISE</code>. If <code>None</code>, the value for <code>self.unknown</code> is used.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Passed to the JSON decoder</p> <code>{}</code> <p>Returns:</p> Type Description <code>Model</code> <p>if <code>many</code> is set to <code>False</code></p> <code>list[Model]</code> <p>if <code>many</code> is set to <code>True</code></p>"}]}